# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_tui.ipynb.

# %% auto 0
__all__ = ['TEXTUAL_CSS', 'TimeDisplay', 'StatusCard', 'RecordingState', 'TranscriptionTUI']

# %% ../nbs/05_tui.ipynb 2
from time import monotonic
from enum import Enum, auto
import asyncio

from textual import on, events
from textual.app import App, ComposeResult
from textual.reactive import reactive
from textual.containers import Container, VerticalGroup, Grid, HorizontalGroup, CenterMiddle, Horizontal
from textual.widgets import Header, Footer, Static, Digits, Button, Label, TextArea, Log, Select

from .live import LiveTranscriber
from .ai import has_session, start_session, apply_instruction, current_transcript, reset_session

# %% ../nbs/05_tui.ipynb 3
TEXTUAL_CSS = """
    Screen {
        background: $surface;
    }
    Header {
        background: $primary;
    }

    StatusCard {
        width: auto;
        row-span: 2;
        border: solid $primary;
        border-title-align: center;
        height: 100%;
        padding: 1 0;
    }

    #info-card {
        width: auto;
        border: solid #6b7280;
        border-title-align: center;
        height: 100%;
        column-span: 3;
        padding: 1;
    }

    #transcript-field {
        width: 100%;
        border: solid $warning;
        border-title-align: center;
        height: 100%;
        column-span: 3;
        padding: 1;
    }

    #top-cards {
        layout: grid;
        grid-size: 4 2;
        grid-rows: 1fr;
        grid-columns: 1fr;
        grid-gutter: 1;
        margin: 1;
        height: 40vh;
    }

    #textfield {
        width: 100%;
        margin: 1;
        padding: 1;
        border: solid #8b5cf6;
        border-title-align: center;
        height: 50vh;
    }

    

    #status {
        content-align: center middle;
    }

    #status-time {
        border: double green;
        width: auto;
        padding: 0 1;
        margin: 1 0;
    }

    #media-controls {
        dock: bottom;
        align: center middle;
    }

    #media-controls Button {
        min-width: 20;
    }

    #pause,
    #resume,
    #stop {
        display: none;
    }

    .active #start {
        display: none;
    }
    .active #pause,
    .active #stop {
        display: block;
    }
    .active #status {
        color: $error;
    }

    .paused #start {
        display: none;
    }
    
    .paused #status {
        color: $warning;
    }

    .paused #resume,
    .paused #stop {
        display: block;
    }
"""

# %% ../nbs/05_tui.ipynb 4
class TimeDisplay(Digits): 
    """Custom time display widget""" 
    accumulated_time = 0 
    time_elapsed = reactive(0) 
    def on_mount(self): 
        self.update_timer = self.set_interval( 
            1 / 60, 
            self.update_time_elapsed, 
            pause=True 
        )
    
    def update_time_elapsed(self): 
        self.time_elapsed = self.accumulated_time + (
            monotonic() - self.start_time
        ) 
        
    def watch_time_elapsed(self): 
        time = self.time_elapsed 
        time, seconds = divmod(time, 60) 
        hours, minutes = divmod(time, 60) 
        time_string = f"{hours:02.0f}:{minutes:02.0f}:{seconds:05.2f}" 
        self.update(time_string) 
        
    def start(self): 
        self.start_time = monotonic() 
        self.update_timer.resume() 
        
    def pause(self): 
        self.accumulated_time = self.time_elapsed 
        self.update_timer.pause() 
        
    def stop(self): 
        self.start_time = monotonic() 
        self.accumulated_time = 0 
        self.time_elapsed = 0 
        self.update_timer.pause()

class StatusCard(Label):
    """Recording status card with controls"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.border_title = "Recording Status"

    def compose(self) -> ComposeResult:
        yield Static("‚óã STANDBY", id="status")
        with CenterMiddle():
            yield TimeDisplay("0:00:00", id="status-time")
        with HorizontalGroup(id="media-controls"):
            yield Button.error("‚óè REC <space>", id="start")
            yield Button.success("‚è∏ PAUSE <space>", id="pause")
            yield Button.warning("‚ñ∂ RESUME <space>", id="resume")
            yield Button("‚óº STOP <s>", id="stop")

# %% ../nbs/05_tui.ipynb 6
class RecordingState(Enum):
    IDLE = auto()
    RECORDING = auto()
    PAUSED = auto()
    EDIT = auto()

class TranscriptionTUI(App):

    TITLE = "TUI Writer"
    SUB_TITLE = "Design Template"
    CSS = TEXTUAL_CSS
    AUTO_FOCUS = None
    WHISPER_MODELS = [
        ("Tiny      ‚ö°  Ultra fast - Low accuracy", "tiny"),
        ("Base      ‚ö°  Fast       - Decent accuracy", "base"),
        ("Small     ‚öñ  Balanced  - Good accuracy", "small"),
        ("Medium    üê¢  Slow    - High accuracy",  "medium"),
        ("Large     üê¢  Very Slow - Best accuracy", "large"),
    ]

    state = reactive(RecordingState.IDLE)


    def watch_state(self, new_state: RecordingState) -> None:
        self.status_card.remove_class("active")
        self.status_card.remove_class("paused")

        match new_state:
            case RecordingState.IDLE:
                self.status_text.update("‚óã STANDBY")
                self.time_display.stop()
            case RecordingState.RECORDING:
                self.status_card.add_class("active")
                self.status_text.update("‚óè RECORDING...")
                self.time_display.start()
            case RecordingState.PAUSED:
                self.status_card.add_class("paused")
                self.status_text.update("‚è∏ PAUSED")
                self.time_display.pause()
            case RecordingState.EDIT:
                self.status_card.add_class("active")
                self.status_text.update("‚óè LIVE EDITING...")
                self.time_display.pause()

    BINDINGS = [
        ("q", "quit", "Quit"),
        ("space", "toggle_recording", "Start/Pause/Resume"),
        ("s", "stop_recording", "Stop")
    ]

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._task: asyncio.Task | None = None
        self._transcriber: LiveTranscriber | None = None
        self.all_chunks: str = ""
        self.whisper_model = "base"

    def compose(self) -> ComposeResult:
        # Saved to instance variables, to set border_title in on_mount()
        self.info_card = Label(id="info-card")
        self.transcript_field = Label(id="transcript-field")
        self.textfield = Label(id="textfield")

        yield Header(show_clock=True)

        with Container(id="top-cards"):
            yield StatusCard()
            with self.info_card:
                yield Static("AI Transcriber model:")
                yield Select(
                    options=self.WHISPER_MODELS,
                    allow_blank=False,
                    value=self.whisper_model,
                    id="whisper-select",
                )
            yield self.transcript_field
        
        with self.textfield:
            yield Log(id="main-textarea")
        yield Footer()

    # Action methods triggered by key bindings, refers to button-methods
    async def action_toggle_recording(self) -> None:
        if self.state is RecordingState.IDLE:
            await self._start()
        elif self.state is RecordingState.RECORDING:
            await self._pause()
        elif self.state is RecordingState.PAUSED:
            await self._resume()
    
    async def action_stop_recording(self) -> None:
        if self.state is not RecordingState.IDLE:
            await self._stop()

    @on(Button.Pressed, "#start")
    async def _on_start(self, _):
        await self._start()

    @on(Button.Pressed, "#pause")
    async def _on_pause(self, _):
        await self._pause()

    @on(Button.Pressed, "#resume")
    async def _on_resume(self, _):
        await self._resume()

    @on(Button.Pressed, "#stop")
    async def _on_stop(self, _):
        await self._stop()

    @on(Select.Changed, "#whisper-select")
    def select_changed(self, event: Select.Changed) -> None:
        self.whisper_model = str(event.value)
    
    async def on_key(self, event: events.Key) -> None:
        if event.key != "e":
            return

        if self.state is not RecordingState.EDIT:
            # save current state before switching to edit-state
            self._old_state = self.state

            if self.state is RecordingState.RECORDING:
                await self._pause()
            
            await self._start_edit()
            
        else:
            self.transcript_block.loading = True
            self.main_textarea.loading = True
            await self._stop_edit()
            self.transcript_block.loading = False
            self.main_textarea.loading = False
            self.plan = None
            self.edit_instructions = ""
            
            # Restore previous state safely
            self.state = getattr(self, "_old_state", RecordingState.PAUSED)
            # If previous state was recording, resume automatically.
            if self.state is RecordingState.RECORDING:
                await self._resume()

    async def _start_edit(self) -> None:
        self.current_transcript = start_session(self.all_chunks)
        self._transcriber = LiveTranscriber(
            model_id=self.whisper_model,
            language="en",
            on_transcript=self.on_transcript,
            vad_threshold=0.5,
            min_speech_duration_ms=250,
            min_silence_duration_ms=500,
        )
        self._task = asyncio.create_task(self._transcriber.start())
        self.state = RecordingState.EDIT

    async def _stop_edit(self) -> None:
        try:
            if self._transcriber:
                self._transcriber.stop()
            if self._task:
                await self._task
            if self._transcriber:
                await self._transcriber.flush()
        finally:
            self._transcriber = None
            self._task = None
            self.current_transcript, self.plan = apply_instruction(self.edit_instructions)
            reset_session()
            self.all_chunks = self.current_transcript
            ops_text = f"Plan: {self.plan.model_dump_json(indent=2)}"
            self.transcript_block.update(ops_text)
            self.main_textarea.clear()
            self.main_textarea.write_lines(self.all_chunks.splitlines(True))

    def on_transcript(self, instruction: str) -> None:
        instruction = (instruction or "").strip()
        if not instruction:
            return
        prev = getattr(self, "edit_instructions", "")
        self.edit_instructions = (prev + ("\n" if prev else "") + instruction)


    async def _start(self) -> None:
        if self.state is not RecordingState.IDLE:
            return
        self._transcriber = LiveTranscriber(
            model_id=self.whisper_model, language="en",
            on_transcript=self.on_transcript_chunk,
            vad_threshold=0.5, min_speech_duration_ms=250, min_silence_duration_ms=500,
        )
        self._task = asyncio.create_task(self._transcriber.start())
        self.time_display.start()
        self.state = RecordingState.RECORDING

    async def _pause(self) -> None:
        if self.state is not RecordingState.RECORDING:
            return
        try:
            if self._transcriber:
                self._transcriber.stop()
            if self._task:
                await self._task
            if self._transcriber:
                await self._transcriber.flush()
        finally:
            self._task = None
            self._transcriber = None
            self.time_display.pause()
            self.state = RecordingState.PAUSED

    async def _resume(self) -> None:
        if self.state is not RecordingState.PAUSED:
            return
        self._transcriber = LiveTranscriber(
            model_id=self.whisper_model,
            language="en",
            on_transcript=self.on_transcript_chunk,
            vad_threshold=0.5,
            min_speech_duration_ms=250,
            min_silence_duration_ms=500,
        )
        self._task = asyncio.create_task(self._transcriber.start())
        self.time_display.start()
        self.state = RecordingState.RECORDING

    async def _stop(self) -> None:
        if self.state is RecordingState.IDLE:
            return
        try:
            if self._transcriber:
                self._transcriber.stop()
            if self._task:
                await self._task
            if self._transcriber:
                await self._transcriber.flush()
        finally:
            self._transcriber = None
            self._task = None
            self.time_display.stop()
            self.state = RecordingState.IDLE

    def on_transcript_chunk(self, text: str) -> None:
        text = (text or "").strip()
        if not text or self.state is RecordingState.IDLE:
            return
        self.all_chunks += text + "\n"
        self.main_textarea.write_line(text)

    def on_mount(self) -> None:
        self.status_card: StatusCard = self.query_one(StatusCard)
        self.status_text: Static = self.query_one("#status", Static)
        self.time_display: TimeDisplay = self.query_one(TimeDisplay)
        self.transcript_block: Label = self.query_one("#transcript-field", Label)
        self.main_textarea: Log = self.query_one("#main-textarea", Log)
        self.transcript_field.border_title = "Edit Operations"
        self.info_card.border_title = "Info"
        self.textfield.border_title = "Full Transcript"

    async def on_unmount(self) -> None:
        await self._stop()
