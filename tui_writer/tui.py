# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_tui.ipynb.

# %% auto 0
__all__ = ['TEXTUAL_CSS', 'HELP_MARKDOWN', 'SettingsModal', 'HelpModal', 'RecordingState', 'TranscriptionTUI']

# %% ../nbs/05_tui.ipynb 2
from enum import Enum, auto
import asyncio
import pyperclip

from textual import on
from textual.app import App, ComposeResult
from textual.reactive import reactive
from textual.containers import Container, Grid, Center
from textual.screen import ModalScreen
from textual.widgets import Header, Footer, Static, Button, Log, Select, Rule, MarkdownViewer

from .live import LiveTranscriber
from .ai import start_session, apply_instruction, reset_session

# %% ../nbs/05_tui.ipynb 3
TEXTUAL_CSS = """
    Screen {
        align: center top;
    }
    Header {
        background: $background;
    }
    .recording {
        background: $error;
    }

    #main-textarea {
        hatch: horizontal $boost 80%;
        background: $boost;
        margin: 1 3;
        padding: 2 3;
    }
    
    HelpModal {
        align: center middle;
    }
    #help {
        border: thick $background 80%;
        background: $surface;
        width: 100;
        padding: 0 2;
        align: center top;
        height: 90%;
        max-height: 70;
    }

    
    SettingsModal {
        align: center middle;
    }
    #settings {
        border: thick $background 80%;
        background: $surface;
        width: 100;
        padding: 0 2;
        align: center top;
        height: 20;
    }
    #modal-header {
        content-align: center middle;
        margin: 1 0;
    }
    Rule {
        margin: 0;
    }
    #selections {
        layout: grid;
        grid-size: 3 3;
        grid-rows: 1fr;
        grid-columns: 1fr;
        grid-gutter: 1;
    }
    .select-text {
        height: 100%;
        content-align: center middle;
    }
    Select {
        column-span: 2;
    }
    #save-container {
        column-span: 3;
    }
"""

# %% ../nbs/05_tui.ipynb 4
class SettingsModal(ModalScreen):
    # Available Whisper model options (label, value)
    WHISPER_MODELS = [
        ("Tiny      âš¡  Ultra fast   - Low accuracy", "tiny"),
        ("Base      âš¡  Fast         - Decent accuracy", "base"),
        ("Small     âš–   Balanced    - Good accuracy", "small"),
        ("Medium    ðŸ¢  Slow        - High accuracy",  "medium"),
        ("Large     ðŸ¢  Very Slow   - Best accuracy", "large-v3"),
        ("Tiny.en   English-only    - faster", "tiny.en"),
        ("Base.en   English-only    - faster", "base.en"),
        ("Small.en  English-only    - faster", "small.en"),
        ("Medium.en English-only    - faster", "medium.en"),
        ("Large.en  English-only    - faster", "large-v3.en")
    ]
    WHISPER_LANGUAGES = [
        ("English", "en"),
        ("Norwegian", "no"),
        ("Swedish", "sv"),
        ("Danish", "da"),
        ("Finnish", "fi"),
        ("German", "de"),
        ("Dutch", "nl"),
        ("French", "fr"),
        ("Spanish", "es"),
        ("Portuguese", "pt"),
        ("Italian", "it"),
        ("Polish", "pl"),
        ("Czech", "cs"),
        ("Slovak", "sk"),
        ("Hungarian", "hu"),
        ("Greek", "el"),
        ("Turkish", "tr"),
        ("Russian", "ru"),
        ("Ukrainian", "uk"),
        ("Arabic", "ar"),
        ("Hebrew", "he"),
        ("Hindi", "hi"),
        ("Bengali", "bn"),
        ("Urdu", "ur"),
        ("Persian (Farsi)", "fa"),
        ("Thai", "th"),
        ("Vietnamese", "vi"),
        ("Indonesian", "id"),
        ("Malay", "ms"),
        ("Filipino (Tagalog)", "tl"),
        ("Chinese (Mandarin)", "zh"),
        ("Chinese (Cantonese)", "yue"),
        ("Japanese", "ja"),
        ("Korean", "ko"),
        ("Swahili", "sw"),
        ("Afrikaans", "af"),
        ("Romanian", "ro"),
        ("Bulgarian", "bg"),
        ("Serbian", "sr"),
        ("Croatian", "hr"),
        ("Slovenian", "sl"),
        ("Estonian", "et"),
        ("Latvian", "lv"),
        ("Lithuanian", "lt"),
    ]

    def __init__(self, model, language):
        self.model = model
        self.language = language
        super().__init__()

    def compose(self) -> ComposeResult:
        with Container(id="settings"):
            yield Static("SETTINGS", id="modal-header")
            yield Rule(line_style="heavy")
            with Grid(id="selections"):
                yield Static("Transcribing model:", classes="select-text")
                yield Select(
                        options=self.WHISPER_MODELS,
                        allow_blank=False,
                        value=self.model,
                        id="whisper-model"
                )
                yield Static("Language:", classes="select-text")
                yield Select(
                        options=self.WHISPER_LANGUAGES,
                        allow_blank=False,
                        value=self.language,
                        id="whisper-language"
                )
                yield Center(
                    Button.success("Close (esc)", id="save"),
                    id="save-container",
                )


    # Whisper selectors
    @on(Select.Changed, "#whisper-model")
    def on_model_changed(self, event: Select.Changed) -> None:
        self.model = str(event.value)

    @on(Select.Changed, "#whisper-language")
    def on_language_changed(self, event: Select.Changed) -> None:
        self.language = str(event.value)

    def key_escape(self) -> None:
        self.dismiss([self.model, self.language])

    def on_button_pressed(self) -> None:
        self.dismiss([self.model, self.language])


# %% ../nbs/05_tui.ipynb 5
HELP_MARKDOWN = """\
# TUI Writer

Help screen on how to use and customize TUI Writer.

## How to use

### Live transcriber:

- Press SPACE on your keyboard, you should see the top bar turn red.
- Simply start speaking and you should see the transcriber in action.
- Stop transcribing by pressing SPACE again.

### Live editing:
If you want to change any of the transcribed text:

- Press 'e' to get started.
- Audibly tell the AI what edits you want.
- Press 'e' again to send the instruction to the AI.

If the edit did not go as planned:
- do this
"""

class HelpModal(ModalScreen):
    def compose(self) -> ComposeResult:
        with Container(id="help"):
            markdown_viewer = MarkdownViewer(HELP_MARKDOWN, show_table_of_contents=True)
            markdown_viewer.code_indent_guides = False
            yield markdown_viewer
            yield Center(Button("Close (esc)", variant="primary"))

    def on_button_pressed(self) -> None:
        self.app.pop_screen()

    def key_escape(self) -> None:
        self.app.pop_screen()

# %% ../nbs/05_tui.ipynb 7
class RecordingState(Enum):
    """High-level states the TUI can be in."""
    IDLE = auto()       # Not recording
    RECORDING = auto()  # Live transcription is running
    EDIT = auto()       # Voice-based editing mode

class TranscriptionTUI(App):

    CSS = TEXTUAL_CSS
    AUTO_FOCUS = False

    # Reactive state triggers watch_state() automatically when changed
    state = reactive(RecordingState.IDLE)

    BINDINGS = [
        ("q", "quit", "Quit"),
        ("?", "help_modal", "Help"),
        ("s", "settings_modal", "Settings"),
        ("space", "toggle_recording", "Start/Stop"),
        ("e", "make_edits", "Talk to edit"),
        ("c", "copy_transcription", "Copy transcript")
    ]

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._task: asyncio.Task | None = None
        self._transcriber: LiveTranscriber | None = None
        self.all_chunks: str = ""

        self.whisper_model = "base"
        self.language = "en"

    def compose(self) -> ComposeResult:
        """Construct and layout all UI widgets."""
        yield Header(show_clock=True)
        yield Log(id="main-textarea", auto_scroll=True)
        yield Footer()

    # Action methods triggered by key bindings, refers to button-methods
    async def action_toggle_recording(self) -> None:
        """Spacebar: start if idle, stop if currently recording."""
        if self.state is RecordingState.IDLE:
            await self._start()
            self.state = RecordingState.RECORDING
        elif self.state is RecordingState.RECORDING:
            self.title = "STOPPING..."
            await self._stop()
            self.state = RecordingState.IDLE

    def action_copy_transcription(self) -> None:
        if self.all_chunks:
            pyperclip.copy(self.all_chunks)
            self.notify("Copied transcription", title="Copied to clipboard!")
        else:
            self.notify("Nothing to copy yet!", severity="warning", title="Oops!")

    def action_settings_modal(self) -> None:
        self.push_screen(SettingsModal(self.whisper_model, self.language), self.apply_settings)

    def apply_settings(self, settings):
        self.whisper_model = settings[0]
        self.language = settings[1]

    def action_help_modal(self) -> None:
        self.push_screen(HelpModal())

    async def action_make_edits(self) -> None:
        if self.state is not RecordingState.EDIT:
            if not self.all_chunks:
                self.notify("There is nothing to apply edits on", severity="warning", title="WARNING!")
                return
            
            self.edit_instructions = ""
            await self._start_edit()
            self.state = RecordingState.EDIT 
        else:
            # Leaving edit mode
            self.main_textarea.loading = True
            await self._stop()

            if len(self.edit_instructions.strip().split()) < 2:
                self.notify("Too short edit instruction!", severity="warning", title="WARNING!")
            else:
                self.all_chunks, self.plan = apply_instruction(self.edit_instructions)
                reset_session()
                self.main_textarea.clear()
                self.main_textarea.write_lines(self.all_chunks.splitlines(True))
            
            self.main_textarea.loading = False
            self.plan = None
            self.state = RecordingState.IDLE

    # Live edit mode helpers
    async def _start_edit(self) -> None:
        """Start edit session and transcriber."""
        start_session(self.all_chunks)
        self._transcriber = LiveTranscriber(
            model_id=self.whisper_model,
            language=self.language,
            on_transcript=self.on_edit_transcript,
            vad_threshold=0.5,
            min_speech_duration_ms=250,
            min_silence_duration_ms=500,
        )
        self._task = asyncio.create_task(self._transcriber.start())


    # Transcription lifecycle
    async def _start(self) -> None:
        """Initialize and start live transcription."""
        self._transcriber = LiveTranscriber(
            model_id=self.whisper_model, language=self.language,
            on_transcript=self.on_transcript_chunk,
            vad_threshold=0.5, min_speech_duration_ms=250, min_silence_duration_ms=500,
        )
        self._task = asyncio.create_task(self._transcriber.start())

    async def _stop(self) -> None:
        """Stop active transcriber and cleanup task."""
        try:
            if self._transcriber:
                await self._transcriber.stop()  # â† Added await!
            if self._task:
                await self._task
        finally:
            self._transcriber = None
            self._task = None

    # Callback handlers
    def on_transcript_chunk(self, text: str) -> None:
        """Called whenever the transcriber produces a new text chunk."""
        text = (text or "").strip()
        if not text:
            return
        self.all_chunks += text + "\n"
        self.main_textarea.write_line(text)
    
    def on_edit_transcript(self, instruction: str) -> None:
        """Collects spoken edit instructions during edit mode."""
        instruction = (instruction or "").strip()
        if not instruction:
            return
        prev = getattr(self, "edit_instructions", "")
        self.edit_instructions = (prev + ("\n" if prev else "") + instruction)

    # UI state watcher (reactive)
    def watch_state(self, new_state: RecordingState) -> None:
        """Reactively update UI when recording state changes."""
        self.sub_title = ""

        match new_state:
            case RecordingState.IDLE:
                self.title = "â—‹ STANDBY"
                self.header.remove_class("recording")
            case RecordingState.RECORDING:
                self.title = "â— RECORDING"
                self.header.add_class("recording")
            case RecordingState.EDIT:
                self.title = "â— TALK TO EDIT"
                self.sub_title = "press 'e' to apply the instructions"
                self.header.add_class("recording")

    # Mount / Unmount lifecycle
    def on_mount(self) -> None:
        """Initialize widget references and set titles."""
        self.title = "â—‹ STANDBY"
        self.header = self.query_one(Header)
        self.main_textarea: Log = self.query_one("#main-textarea", Log)
        self.theme = "textual-dark"

    async def on_unmount(self) -> None:
        """Cleanly stop background tasks when app closes."""
        await self._stop()
