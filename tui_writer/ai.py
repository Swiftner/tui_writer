# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ai.ipynb.

# %% auto 0
__all__ = ['ReplaceAllOp', 'RegexReplaceOp', 'InsertAtOp', 'InsertAfterOp', 'DeleteOp', 'EditPlan', 'has_session',
           'start_session', 'apply_instruction', 'current_transcript', 'reset_session', 'ai_chat',
           'summarize_transcript', 'explain_edits', 'improve_transcript']

# %% ../nbs/01_ai.ipynb 2
from typing import List, Dict, Literal, Union
from pydantic import BaseModel, ConfigDict, Field, model_validator
from dotenv import load_dotenv
import re
import json
from lisette import Chat


load_dotenv()

# %% ../nbs/01_ai.ipynb 4
# --- Replace all ------------------------------------------------------------

class ReplaceAllOp(BaseModel):
    """Represents a 'replace all' text operation."""
    op: Literal["replace_all"]
    find: str = Field(..., min_length=1)
    replace: str = Field(..., min_length=0)
    model_config = ConfigDict(extra="forbid")


# --- Regex replace ------------------------------------------------------------

class RegexReplaceOp(BaseModel):
    """Represents a regex-based find/replace operation."""
    op: Literal["regex_replace"]
    pattern: str = Field(..., min_length=1)
    replacement: str = Field(..., min_length=0)
    model_config = ConfigDict(extra="forbid")

    @model_validator(mode="after")
    def _validate_regex(cls, v: "RegexReplaceOp"):
        # Precompile regex to ensure it's valid
        try:
            re.compile(v.pattern)
        except re.error as e:
            raise ValueError(f"Invalid regex pattern: {e}") from e
        return v

# --- Insert at absolute position ---------------------------------------------

class InsertAtOp(BaseModel):
    """Insert text at an absolute character position (0-indexed)."""
    op: Literal["insert_at"]
    text: str = Field(..., min_length=1)
    position: int = Field(..., ge=0)
    model_config = ConfigDict(extra="forbid")

# --- Insert after marker ------------------------------------------------------

class InsertAfterOp(BaseModel):
    """Insert text after the first occurrence of a marker string."""
    op: Literal["insert_after"]
    text: str = Field(..., min_length=1)
    after: str = Field(..., min_length=1)
    model_config = ConfigDict(extra="forbid")

# --- Delete -------------------------------------------------------------------

class DeleteOp(BaseModel):
    """Delete exact text (first or all occurrences)."""
    op: Literal["delete"]
    text: str = Field(..., min_length=1)
    all_occurrences: bool = False
    model_config = ConfigDict(extra="forbid")


# --- Edit plan container ------------------------------------------------------

class EditPlan(BaseModel):
    """Represents a list of text operations to apply sequentially."""
    ops: List[
        Union[
            ReplaceAllOp,
            RegexReplaceOp,
            InsertAtOp,
            InsertAfterOp,
            DeleteOp,
        ]
    ]
    model_config = ConfigDict(extra="forbid")

# %% ../nbs/01_ai.ipynb 6
# --- session state (module-level) ---
_messages: List[Dict[str, str]] | None = None
_current: str | None = None

def _new_conversation(transcript: str) -> List[Dict[str, str]]:
    """Create a new message list with system + assistant context."""
    return [
        {
            "role": "system",
            "content": (
                "You are a precise text editor that outputs ONLY valid JSON matching the EditPlan schema.\n\n"
                "Available operations:\n"
                "1. replace_all — exact literal text only (no regex)\n"
                "   fields:\n"
                "       - find: the exact text to replace\n"
                "       - replace: replacement text for every occurrence\n\n"
                "2. regex_replace - pattern-based replacements (e.g., dates)\n"
                "   fields:\n"
                "       - pattern: regex pattern to match (e.g., (\\d{4})-(\\d{2})-(\\d{2}) for dates)\n"
                "       - replacement: replacement string using \\1, \\2 for capture groups\n\n"
                "3. insert_at — insert text at an absolute index (0 = start)\n"
                "   fields:\n"
                "       - text: text to insert\n"
                "       - position: integer index to insert at\n\n"
                "4. insert_after — insert text after a marker\n"
                "   fields:\n"
                "       - text: text to insert\n"
                "       - after: insert after the first occurrence of this string\n"
                "       (ALWAYS provide a space in the string if needed when doing insert)\n\n"
                "5. delete — remove exact text\n"
                "   fields:\n"
                "       - text: the exact text to remove\n"
                "       - all_occurrences: true = remove all, false = only first (default false)\n\n"
                "RULES:\n"
                "- If you see regex patterns or date formats, you MUST use regex_replace, NOT replace_all!\n"
                "- When interpreting natural or spoken language, infer the user's intent precisely and map it to the correct fields.\n"
                "- ALWAYS provide a space in text to insert if needed.\n"
                "- Respond ONLY with valid JSON following the EditPlan schema."
            ),
        },
        {
            "role": "assistant",
            "content": f"Current text to edit:\n{transcript}",
        },
    ]


def _set_current_transcript(new_transcript: str) -> None:
    global _messages
    # replace the single assistant transcript message
    for m in _messages:
        if m.get("role") == "assistant":
            m["content"] = f"Current text to edit:\n{new_transcript}"
            return
    # Fallback: insert one if missing
    _messages.insert(1, {
        "role": "assistant",
        "content": f"Current text to edit:\n{new_transcript}",
    })

# %% ../nbs/01_ai.ipynb 8
def _plan_edits(instruction: str, model: str = "gemini/gemini-2.5-flash") -> EditPlan:
    """
    Append a user instruction, call the model with structured output, and return the parsed plan.
    """
    global _messages

    # Add the new instruction to the conversation
    _messages.append({"role": "user", "content": f"Instruction: {instruction}"})

    # Use lisette to get structured JSON response
    chat = Chat(model, response_format="json")
    
    # Format messages for lisette (convert our format to lisette's expected format)
    response = chat(messages=_messages, temperature=0)
    
    # Extract the JSON content from response
    content = response.choices[0].message.content
    
    # Parse JSON and validate with Pydantic
    try:
        data = json.loads(content)
        plan = EditPlan.model_validate(data)
        return plan
    except (json.JSONDecodeError, Exception) as e:
        raise RuntimeError(f"Failed to parse model response as EditPlan: {e}\nResponse: {content}")


def _apply_plan(transcript: str, plan: EditPlan) -> str:
    """
    Apply all operations from the EditPlan to the given transcript.
    """
    updated = transcript
    for op in plan.ops:
        if op.op == "replace_all":
            updated = updated.replace(op.find, op.replace)
        elif op.op == "regex_replace":
            updated = re.sub(op.pattern, op.replacement, updated)
        elif op.op == "insert_at":
            pos = max(0, min(op.position, len(updated)))
            updated = updated[:pos] + op.text + updated[pos:]
        elif op.op == "insert_after":
            idx = updated.find(op.after)
            if idx != -1:
                insert_pos = idx + len(op.after)
                updated = updated[:insert_pos] + op.text + updated[insert_pos:]
        elif op.op == "delete":
            if op.all_occurrences:
                updated = updated.replace(op.text, "")
            else:
                # Delete first occurrence only
                idx = updated.find(op.text)
                if idx != -1:
                    updated = updated[:idx] + updated[idx + len(op.text):]
    return updated

# %% ../nbs/01_ai.ipynb 10
def has_session() -> bool:
    """Return True if an edit session is initialized."""
    return _messages is not None and _current is not None

def start_session(initial_transcript: str) -> str:
    """Seed a new session with the initial transcript and return it."""
    global _messages, _current
    _current = initial_transcript
    _messages = _new_conversation(initial_transcript)
    return _current

def apply_instruction(instruction: str, model: str = "gemini/gemini-2.5-flash") -> str:
    """Apply an instruction to the current transcript and return the updated text."""
    global _current
    if not has_session():
        raise RuntimeError("No session. Call start_session() first.")
    plan = _plan_edits(instruction, model)
    _current = _apply_plan(_current, plan)
    _set_current_transcript(_current)
    return _current

def current_transcript() -> str:
    """Get the latest edited transcript (or '' if none)."""
    return _current or ""

def reset_session() -> None:
    """Clear session state."""
    global _messages, _current
    _messages, _current = None, None

# %% ../nbs/01_ai.ipynb 12
def ai_chat(
    prompt: str, 
    model: str = "gemini/gemini-2.5-flash", 
    enable_search: bool = False
) -> str:
    """
    General-purpose AI chat using lisette for multi-provider support.
    
    Args:
        prompt: Question or instruction for the AI
        model: Model identifier (e.g., "gemini/gemini-2.5-flash", "claude-sonnet-4-20250514", "gpt-4o")
        enable_search: Whether to enable web search capabilities
    
    Returns:
        AI response text
        
    Example:
        >>> response = ai_chat("What is the capital of Norway?", enable_search=True)
        >>> print(response)
    """
    search_level = "l" if enable_search else None
    chat = Chat(model, search=search_level)
    response = chat(prompt)
    return response.choices[0].message.content


def summarize_transcript(
    transcript: str, 
    model: str = "gemini/gemini-2.5-flash",
    max_words: int = 100
) -> str:
    """
    Generate a concise summary of a transcript.
    
    Args:
        transcript: The text to summarize
        model: AI model to use
        max_words: Maximum words for the summary
        
    Returns:
        Summary text
    """
    prompt = f"""Summarize this transcript in {max_words} words or less:

{transcript}

Provide a clear, concise summary."""
    return ai_chat(prompt, model)


def explain_edits(original: str, edited: str, model: str = "gemini/gemini-2.5-flash") -> str:
    """
    Get an AI explanation of what changed between two text versions.
    
    Args:
        original: Original text
        edited: Edited/modified text
        model: AI model to use
        
    Returns:
        Natural language explanation of changes
    """
    prompt = f"""Compare these two versions and explain what changed:

ORIGINAL:
{original}

EDITED:
{edited}

Provide a brief, clear explanation of the changes made."""
    return ai_chat(prompt, model)


def improve_transcript(
    transcript: str,
    instructions: str = "Fix grammar, punctuation, and clarity while preserving meaning",
    model: str = "gemini/gemini-2.5-flash"
) -> str:
    """
    Use AI to improve transcript quality with flexible instructions.
    
    Args:
        transcript: Text to improve
        instructions: How to improve it (grammar, clarity, formality, etc.)
        model: AI model to use
        
    Returns:
        Improved transcript text
    """
    prompt = f"""{instructions}

TEXT:
{transcript}

Return ONLY the improved text, no explanations."""
    return ai_chat(prompt, model)
