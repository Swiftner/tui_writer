# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ai.ipynb.

# %% auto 0
__all__ = ['TranscriptEditor']

# %% ../nbs/01_ai.ipynb 3
from lisette import *
import asyncio
import re

# %% ../nbs/01_ai.ipynb 5
class TranscriptEditor:
    """Manages live transcription with AI-assisted editing capabilities."""
    
    # Keywords that suggest the user wants to edit
    EDIT_KEYWORDS = {
        'change', 'replace', 'delete', 'remove', 'fix', 'correct', 
        'modify', 'edit', 'scratch', 'actually', 'wait',
        'no', 'instead', 'undo', 'oops', 'mistake', 'wrong'
    }
    
    def __init__(self, model: str, temperature: float = 0.1):
        self.model = model
        self.temperature = temperature
        self.full_transcript = ""
        self.total_tokens = 0
    
    def _contains_edit_keyword(self, text: str) -> bool:
        """Check if text contains any edit keywords."""
        text_lower = text.lower()
        return any(keyword in text_lower for keyword in self.EDIT_KEYWORDS)
    
    async def process_chunk(self, chunk: str) -> dict:
        """Process a transcription chunk - only calls AI if edit keywords detected."""
        
        # Check if this looks like an edit command
        if self._contains_edit_keyword(chunk):
            # Create a fresh Chat instance for this call (stateless)
            chat = Chat(
                self.model,
                sp="""You are helping with live transcription editing.

You will receive:
1. The current full transcript
2. The latest chunk of text the user just said

Determine if the user wants to edit the transcript:
- If YES: Return ONLY the complete corrected transcript (preserve all newlines)
- If NO (false alarm, they're just speaking normally): Return ONLY the word "APPEND"

Be decisive and fast. Most of the time it's a real edit if you're being called.""",
                temp=self.temperature
            )
            
            # Provide full context to AI
            prompt = f"""Current transcript:
{self.full_transcript}

Latest speech:
{chunk}"""
            
            # Call AI in thread pool to avoid blocking
            response = await asyncio.to_thread(chat, prompt)
            
            result = response.choices[0].message.content.strip()
            tokens = response.usage.total_tokens if hasattr(response, "usage") else 0
            self.total_tokens += tokens
            
            # Check if AI confirmed it's an edit
            if result.startswith("APPEND"):
                # False alarm - just append with newline
                self.full_transcript += chunk + "\n"
                action = "append"
            else:
                # Real edit - replace transcript
                self.full_transcript = result
                action = "edit"
            
            return {
                "transcript": self.full_transcript,
                "action": action,
                "tokens_used": tokens,
                "total_tokens": self.total_tokens,
                "ai_called": True
            }
        else:
            # No edit keywords - just append with newline
            self.full_transcript += chunk + "\n"
            return {
                "transcript": self.full_transcript,
                "action": "append",
                "tokens_used": 0,
                "total_tokens": self.total_tokens,
                "ai_called": False
            }
    
    def get_transcript(self) -> str:
        """Get the current full transcript."""
        return self.full_transcript
    
    async def reset(self):
        """Reset the transcript and token counter."""
        self.full_transcript = ""
        self.total_tokens = 0
