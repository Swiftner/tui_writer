# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_audio.ipynb.

# %% auto 0
__all__ = ['console', 'AudioRecorder']

# %% ../nbs/01_audio.ipynb 1
import sys
import wave
from pathlib import Path
import numpy as np
import sounddevice as sd
from rich.console import Console
from fastcore.basics import patch_to

console = Console()

# %% ../nbs/01_audio.ipynb 3
class AudioRecorder:
    """Audio recording system for capturing microphone input."""
    def __init__(self, sample_rate: int = 16000, channels: int = 1):
        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_file_path = self._get_audio_file_path()
        self.wave_file = None
        self.recording_frames = 0
        self.recording = False

    def _audio_callback(self, indata, frames, time, status):
        if status:
            console.print(f"⚠️ [bold yellow]Audio warning: {status}[/bold yellow]")
        if self.wave_file and self.recording:
            audio_int16 = (indata * 32767).astype(np.int16)
            self.wave_file.writeframes(audio_int16.tobytes())
            self.recording_frames += frames

    def start_recording(self):
        """Start recording audio from the microphone.

        Initiates the audio capture process by validating the audio device,
        preparing the output file, and starting the audio stream. This method
        sets up all the necessary resources for real-time audio recording.

        The recording process runs asynchronously, allowing the main application
        to remain responsive during long recording sessions.
        """
        self._validate_audio_device()
        self._prepare_wave_file()
        self.recording = True

        try:
            self.stream = sd.InputStream(
                samplerate=self.sample_rate, channels=self.channels, callback=self._audio_callback, dtype=np.float32
            )
            self.stream.start()
            return True
        except Exception as e:
            self._close_wave_file()
            raise RuntimeError(f"Failed to initialize audio stream: {e}")

    def stop_recording(self) -> Path:
        """Stop recording and return the audio file path."""
        self.recording = False
        if hasattr(self, 'stream'):
            self.stream.stop()
            self.stream.close()
        self._close_wave_file()

        if self.recording_frames == 0:
            raise ValueError("No audio recorded")

        return self.audio_file_path



# %% ../nbs/01_audio.ipynb 5
@patch_to(AudioRecorder)
def _validate_audio_device(self):
    try:
        default_input = sd.query_devices(kind="input")
        if default_input is None:
            raise RuntimeError("No audio input device found")
    except Exception as e:
        raise RuntimeError(f"Failed to access audio devices: {e}")

@patch_to(AudioRecorder)
def _get_audio_file_path(self) -> Path:
    if sys.platform == "win32":
        cache_dir = Path.home() / "AppData" / "Local" / "hns" / "Cache"
    elif sys.platform == "darwin":
        cache_dir = Path.home() / "Library" / "Caches" / "hns"
    else:
        cache_dir = Path.home() / ".cache" / "hns"

    cache_dir.mkdir(parents=True, exist_ok=True)
    return cache_dir / "last_recording.wav"

@patch_to(AudioRecorder)
def _prepare_wave_file(self):
    self.recording_frames = 0
    self.wave_file = wave.open(str(self.audio_file_path), "wb")
    self.wave_file.setnchannels(self.channels)
    self.wave_file.setsampwidth(2)  # 16-bit audio
    self.wave_file.setframerate(self.sample_rate)

@patch_to(AudioRecorder)
def _close_wave_file(self):
    if self.wave_file:
        self.wave_file.close()
        self.wave_file = None

